# Linus Command Line

## Navigation

- [Linux Distributions](#linux-distributions)
- [Running Linux By Docker](#running-linux-by-docker)
- [Managing Packages](#managing-packages)
- [Linux File System](#linux-file-system)
- [Navigating the File System](#navigating-the-file-system)
- [Manipulating Files and Directories](#manipulating-files-and-directories)
- [Editing and Viewing Files](#editing-and-viewing-files)
- [Redirection](#redirection)
- [Searching for Text in File](#searching-for-text-in-file)
- [Finding Files and Directories](#finding-files-and-directories)
- [Chaining Commands](#chaining-commands)
- [Environment Variables](#environment-variables)
- [Managing Processes](#managing-processes)
- [Managing Users](#managing-users)
- [Managing Groups](#managing-groups)
- [File Permissions](#file-permissions)

## Linux Distributions

Each linux distributions is made to fit specialized needs, like:

- Running servers
- Desktop computers
- Mobile phones
- etc.

Commen distributions

- Ubuntu: Most popular Linux distribution
- Debian
- Alpine: Very small Linux distribution
- Fedora
- CentOS

## Running Linux By Docker

1. In [Docker hub: Search Ubuntu](https://hub.docker.com/_/ubuntu)
1. We can see command that pull the image onto our machine
   ```bash
   $ docker pull ubuntu
   ```
1. Or we can use

   ```bash
   $ docker run ubuntu
   ```

   - If we have the image locally, docker is going to start a container with that image
   - Otherwise, docker is going to pull the image image beind the scene, and start a container

   e.g.

   ```bash
   $ docker run ubuntu
   Unable to find image 'ubuntu:latest' locally
   latest: Pulling from library/ubuntu
   00f50047d606: Pull complete
   Digest: sha256:20fa2d7bb4de7723f542be5923b06c4d704370f0390e4ae9e1c833c8785644c1
   Status: Downloaded newer image for ubuntu:latest
   ```

1. See the list of running containers in Docker, it should be empty
   ```bash
   $ docker ps
   ```
1. See all the containers include the stop ones, should look like:

   ```bash
   $ docker ps -a
   ```

   result should be

   | CONTAINER ID | IMAGE  | COMMAND | CREATED       | STATUS                   | PORTS | NAMES            |
   | ------------ | ------ | ------- | ------------- | ------------------------ | ----- | ---------------- |
   | f98aabf0c779 | ubuntu | "bash"  | 2 minutes ago | Exited (0) 2 minutes ago |       | upbeat_blackwell |

1. Run a command in a new container
   ```bash
   $ docker run -it [image]
   ```
   - `-i` is short for interactive
   - `-t`, allocate a pseudo-TTY
   - The terminal will look like:
     ```bash
     root@ef445caa6797:/#
     ```
     - `root` represents the currently login user, by default, it's root user
     - `ef445caa6797` is the name of the machine, the machine ID is automatically generated by Docker
     - `/` represents where we are in the file system
     - `#` means we have the highest privilege, if we are not root user, it should be a `$`
1. We can use Linux command in the container

   - See the location of this shell program
     ```bash
     $ echo $0
     ```
   - See all the commands we have executed lately
     ```bash
     $ history
     ```
   - Replay the third command in history list
     ```bash
     $ !3
     ```

   NOTE: Linux command is case sensitive

1. To exit out of the docker container bash shell

   Hit `ctrl-D` or

   ```bash
   $ exit
   ```

## Managing Packages

Package Managers

- npm
- yarn
- pip
- NuGet

In ubutu, we also have a package manager called `apt`, short for `advanced package tool`

```bash
$ apt list
```

will show the packages in the database, and we can see the status of the packge, like `apt/now 2.4.7 arm64 [installed,local]` shows the `apt` package is installed

```bash
$ apt update
```

will update the package database, and we can see lots of packages which aren't install

```bash
$ apt install nano
```

If some package aren't install, we can use `apt` to install it, `nano` is a text editor, like `vim`

NOTE: Always update the package database before install a package

## Linux File System

In Linux, our files and directories are organized in a tree in a hierarchical structure.

And `everything is a file`, including devices, directories, network socket, pipes, and so on

We have structure like:

- /
  - bin
  - boot
  - dev
  - etc
  - home
  - root
  - lib
  - var
  - proc

| Directory | Description                                                                                                                     |
| --------- | ------------------------------------------------------------------------------------------------------------------------------- |
| /         | Root directory                                                                                                                  |
| bin       | Which includes binaries or programs                                                                                             |
| boot      | Which includes all the files related to booting                                                                                 |
| dev       | Short for `devices`. All the files that are needed to access devices are store in this directory                                |
| etc       | Short for `editable text configuration`. This is where we have configuration files                                              |
| home      | Where home directories for users are stored. On a machine with multiple users, each user is going to have a home directory here |
| root      | Which is the home directory of the root user, only the root user can access this directory                                      |
| lib       | Which is used for keeping library files like software library dependencies                                                      |
| var       | Short for `variable`. Where files that are updated frequently, like `*.lock` files, applicatioin data, so on                    |
| proc      | Short for `process`. Which includes files that represent running processes                                                      |

## Navigating the File System

- `print working directory`
  ```bash
  $ pwd
  ```
- List the files in the current directory
  ```bash
  $ ls [path/to/file]
  ```
  - `-1`, list one item per line
  - `-l`, list a long listing include more detail
- Change directory, the path can be `related path` or `absoulute path`
  ```bash
  $ cd [path/of/directory]
  ```
  - Go one level up
    ```bash
    $ cd ..
    ```

## Manipulating Files and Directories

- Create
  - Make directories
    ```bash
    $ mkdir [directory_name]
    ```
  - Create a new file
    ```bash
    $ touch [file_name]
    ```
- Update
  - Move files, or change the file name
    ```bash
    $ mv [source] [target]
    ```
- Delete
  - Remove directory entries
    ```bash
    $ rm [file_name]
    ```
  - Remove folder, `-r` means `recursive`
    ```bash
    $ rm -r [directory_name]
    ```

## Editing and Viewing Files

- Concatenate and print files
  ```bash
  $ cat [file_name]
  ```
- For dealing with a long file
  ```bash
  $ more [file_name]
  ```
  - `h`, for operation list
  - `f`, scroll forward
  - `b`, scroll backward
  - `ENTER`, one line forward
  - more detail can see `$ man more`
- `$ less [file_name]`
  - before using `less` command, we have to install it by `$ apt install less`
  - simply use `up` and `down` arrow to scroll
- `$ head [file_name]`, display first lines of a file
  - `$ head -n [number_of_lines] [file_name]`, display the first `number_of_lines` in the file
- `$ tail [file_name]`, like `head` but display the last part of a file

## Redirection

Standard input in Linux: keyboard

Standard output in Linux: screen

But we can always change the source of the input or the output, this is called `redirection`

- `>` to redirect the standard output
- `<` to redirect the standard input

`ls` examples

1. Redirect the content of `file1.txt` from screen to `file2.txt`

   ```bash
   $ cat file1.txt > file2.txt
   ```

   It's mean `cat` will read `file1.txt`, and write the content to `file2.txt`

1. Combine multiple files
   ```bash
   $ cat file1.txt file2.txt > combined.txt
   ```
1. Write simple text to file

   ```bash
   $ echo hello > hello.txt
   ```

1. Write long list information in /etc to file
   ```bash
   $ ls -l /etc > files.txt
   ```

## Searching for Text in File

`grep`, short for `global regular expression print`

- `grep` search is case sensitivity
- `-i`, short for `ignore case`, make case insensitive
- `-r`, short for `recursive`, then we can search all files in the directory

`grep` examples

1. Search `hello` in `file1.txt` and `file2.txt`
   ```bash
   $ grep hello file1.txt file2.txt
   ```
1. Search `hello` in file whoes name starts with `file`
   ```bash
   $ grep hello file*
   ```
1. Search `hello` in all files in the current directory
   ```bash
   $ grep hello -r .
   ```
1. Combine optioin
   ```bash
   $ grep hello -ir .
   ```

## Finding Files and Directories

`find`, for finding files and directories

- `-type`, find file of the specified type
  - `d` for directory
  - `f` for file
- `-name`, file name in a pattern
- `-name`, pattern insensitive

`find` examples

1. See all the files and directories in the current directory recursively
   ```bash
   $ find
   ```
1. See only the directories in the /etc directory recursively
   ```bash
   $ find -type d /etc
   ```
1. See all the files name start with `f` in the current directory recursively
   ```
   $ find -type f -name "f*"
   ```

## Chaining Commands

1. `;`, semicolon, seperate the commands

   ```bash
   $ mkdir test; cd test; echo done
   ```

   All the commands will be executed on after another

   If any of the commands get error, the rest commands still get executed

1. `&&`, double ampersands, the `AND` operator
   If one command is fails, the rest command will not get executed

   ```bash
   $ command_1 && command_2 && command_3
   ```

   For example, if `command_2` fails, `command_3` will not get executed, but `command_1` still works

1. `||`, `OR` operator

   ```bash
   $ command_1 || command_2
   ```

   If `command_1` works, `command_2` will NOT get executed

   If `command_1` fails, `command_2` will get executed

1. `|`, piping

   ```bash
   $ ls /bin | less
   ```

   We got the result from `ls /bin`, and create a pipe, then send it to `less`

1. `\`, back slash, split commands into multiple lines
   ```bash
   $ mkdir hello;\
   cd hello;\
   echo done
   ```

## Environment Variables

`printenv`, print out the environment

```bash
$ printenv
```

We can get bunch of key value pairs separated by an equal sign

- `PATH` in the environment variables

  - Error: the program or the command was not found. Because even though we installed the program, but the program's directory didn't add to the PATH

  Get `PATH`

  ```bash
  $ printenv PATH
  ```

  or

  ```bash
  $ echo $PATH
  ```

1. Set an environment variable

   - `$ export DB_USER=Ian`

     The $DB_USER is only available in the current terminal session

   - We have to write it to a special file, which is `~/.bashrc`, to make it persistent

     e.g.

     ```bash
     $ DB_USER=Ian >> ~/.bashrc
     ```

     The `~/.bashrc` file is the user's personal startup file.

     Every time a user log in, Linux loads this command from the user's home directory

     NOTE: Use `>>` append content to `~/.bashrc`. NOT `>`, or the content in `~/.bashrc` will be overwrite

     NOTE_2: DO NOT save any sensitive information in environment variables

1. Reload the `~/.bashrc` file

   ```bash
   $ source ~/.bashrc
   ```

   The changes we make to `~/.bashrc` are only effective in the next terminal sessioin. So if we want to make it works, we have to exit and open the container again, or use `source` command to reload `~/.bashrc`

## Managing Processes

A process is an instance of running program, we can see all the running processes by running

```bash
$ ps
```

We should see

| PID | TTY   | TIME     | CMD  |
| --- | ----- | -------- | ---- |
| 1   | pts/0 | 00:00:00 | bash |
| 9   | pts/0 | 00:00:00 | ps   |

- `PID` is an unique identifier, which is generated by the operating system
- `TTY` is short for `teletype`, we can the type of terminal the user is login to, and `pts` is short for `pseudo terminal

  If we open another terminal and start this container, and execute `ps`, we're gonna see `pts/1`

  In TTY column, we can see which terminal the user is login to

- `Time` is the amount of CPU time each process onsumed

`kill` command, terminate or signal a process

```bash
$ kill [PID]
```

Practice

1. Use `sleep` command create a long process, and make it run in background
   ```bash
   $ sleep 100 &
   # 100 means sleep for 100 seconds
   # `&`, ampersand here make process run in background
   ```
1. Use `ps` command to see the PID
1. Use `kill` command kill the process

## Managing Users

Goal: create a new user, and login as that user

- `useradd`, for adding a user
- `usermod`, for modifying a user
- `userdel`, for deleting a user

1. `-m` in `useradd`, create a home directory for the user
   ```bash
   $ useradd -m john
   ```
1. The user we created is stored in a configuration file in the `/etc` directory
1. To see the user information, we can see the `passwd` file in `/etc`. NOTE: Although the name is misleading, passwords aren't store here

   ```bash
   $ cat /etc/passwd
   ```

   and we can see

   `john:x:1000:1000::/home/john:/bin/sh`

   The `x` means password is stored somewhere else

   The first `1000` is user id

   The second `1000` is group id

   At the last `/bin/sh` is the shell program used when this user login

1. Try to change the shell when user login

   ```bash
   $ usermod -s /bin/bash john
   ```

   `-s` means new login shell for the user account

1. Then john in `/etc/passwd` should be `john:x:1000:1000::/home/john:/bin/bash`
1. BTW, password store in `/etc/shadow`, with an encrypted format
1. keep the container open, and in the other terminal login as john
   ```bash
   $ docker exec -it -u john [container_id] bash
   ```
1. john, a.k.a `john@729b9e21160d:/$`, is different from the root user `root@729b9e21160d:/#`
   The `$` means it's just a regular user

   So if we access the `/etc/shadow` file by john, we will get permission denied

   And the home directory will be `/home/john`

1. If we want to delete john, just use `userdel`
   ```bash
   $ userdel john
   ```

Different between `useradd` and `adduser`

| useradd                         | adduser                                                                                                     |
| ------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| The original API that was built | A Perl script that is more interactive, and user `useradd` under the hood                                   |
|                                 | By using `adduser`, we have a chance to set the password, and set up additional information about this user |

## Managing Groups

About the group in Linux

1. Each user has one primary group
   It's automatically created when we create a new user
   It's a group use the same name as user
1. Each user has 0 or more supplementary group, where these group seperated

Why primary group?

> Deal with the problem like:
>
> john is part of 5 groups, and he wants to create a new file, each file belong to one user and one group
>
> The question is if john is prt of 5 groups, which group should we use for only that new file john is gonna create?
>
> That's why we need primary group

We have similar command like managing users

- `groupadd`
- `groupmod`
- `groupdel`

1. Create a new group
   ```bash
   $ groupadd developers
   ```
1. We can see all the groups in `/etc/group`
1. Add a user to a group with `usermod -G`

   ```bash
   $ usermod -G developers john
   ```

1. See the record for john

   ```bash
   $ cat /etc/passwd | grep john
   ```

   or

   ```bash
   $ grep john /etc/passwd
   ```

   But it only show the primary group, where is the secondary group?

1. See the groups of the user by use `group` command
   ```bash
   $ groups john
   ```

## File Permissions

1. Create a file
   ```bash
   $ cd /home && touch deploy.sh && echo echo hello >> deploy.sh && cat deploy.sh
   ```
1. See the long list of the file

   ```bash
   $ ls -l
   ```

   We should see

   `-rw-r--r-- 1 john john 11 Sep 15 14:12 deploy.sh`

1. Here is the `-rw-r--r--` part explanation
   - the first letter
     - `d` means it's a directory
     - `-` means it's a file
   - the rest 9 letters devided into three groups
     - each group we have
       - `r` for reading permission
       - `w` for writing permission
       - `x` for execute permission
     - left 3 letters group
       Reprecents the permissions for the user who owns this file
     - middle 3 letters group
       Reprecents the permissions for the group that own this file
     - right 3 letters group
       Reprecents the permissions for everyone else
1. Change the permission by `chmod` command
   - `u` for user, `g` for group, `o` for others
   - Add an execute permission for user
     ```bash
     $ chmod u+x deploy.sh
     ```
   - Remove an read permission for others
     ```bash
     $ chmod o-r deploy.sh
     ```
   - Also we can combine groups like
     ```bash
     $ chmod og+x+w-r file1.sh *.sh
     ```
